# 7.1 快速排序的描述

标签（空格分隔）： 快速排序

---
###笔记
快速排序的最坏情况下的时间复杂度很差O(n<sup>2</sup>)，但是快速排序通常是实际排序应用中最好的选择，因为它的**平均性能非常好**。它的期望时间复杂度是θ(nlogn)，并且其中的隐含的常数因子非常小，并且可以进行**原址排序**。

快速排序和归并排序一样，同样使用了**分治**的思想：  
 * 分解，数组A[p...r]被划分为两个**（可能为空）**的子数组A[p...q-1]和A[q+1...r]，使得A[p...q-1]中的每个元素都**小于等于**A[q]，而A[q]也小于<font color=red>等于</font>A[q+1..r]中的每个元素。其中计算下标q也是划分过程的一部分。
 * 解决，递归调用堆快速排序，对子数组进行排序。
 * 合并，因为是原址排序，所以并不需要合并，数组A[p..r]已经有序。
 
```c++
//快速排序
QuickSort(A, p, r)
    if (p < r)
        q = Partition(A, p, r)
        QuickSort(A, p, q-1)
        QuickSort(A, q+1, r)
```
```c++
//算法关键部分
//数组的划分
Partition(A,p,r)
    x = A[r]    //作为主元
    i = p-1     //i表明的是小于等于主元的元素中最后一个元素的位置
    for j = p to r-1
        if A[j] <= x
            i = i+1
            exchange A[i] with A[j]
    exchange A[i+1] with A[r]
    return i+1    
```

 > `x = A[r]`作为主元，划分也是围绕主元进行的。`i`表明的是小于等于主元的元素中最后一个元素的位置，在最后也是把这个位置后的第一个元素（大于主元的第一个元素）与主元交换。Partition在数组A[p..r]上的时间复杂度是θ(n)，其中n=r-p+1。

![此处输入图片的描述][1]

---
###练习（无答案）
7.1-1：本上。  
7.1-2：返回的是r。因为Partition维护四个部分，第一个部分小于等于主元，第二个部分都大于主元，所以如果第一个部分的最后一个元素(i)等于第二个部分的第一个元素(i+1)，则直接返回`(p+r)/2`。  
7.1-4：大于该小于，第一部分大于等于主元，第二部分小于主元。



  [1]: https://github.com/wj1066/pictures/blob/master/7.1-1.jpg