# 23.1 Growing a minimum spanning tree

标签： 最小生成树 图

---
###前言
对连通无向图G=(V,E)，我们希望找到一个无环子集T属于E，能够将所有结点连接起来，又具有最小的权重。由于T是无环的，并且连通所有的结点，因此T必然是一棵树，我们称这样的树为**生成树**。求取权值最小的生成树问题为**最小（权重）生成树问题**。

> 针对有向图，也具有最小生成树，如果通常叫做最小树形图。这里不做讨论

本章我们讨论Kruskal和Prim算法，如果使用普通的二叉堆，可以将这两个算法的时间复杂度限制在O(ElgV)。使用斐波那契堆Prim算法的运行时间将改善为O(E+VlgV)。

两种最小生成树的算法都是**贪心算法**，虽然贪心不能保证一个全局最优的解决方案。但是对于最小生成树问题，可以证明某些贪心策略确实能找到一棵权重最小的生成树。

###笔记
本章两个算法虽然都是使用贪心策略，但是他们的贪心策略有所不同。贪心策略可以用下面的通用方法来表述，通用方法在每个时刻生长最小生成树的一条边，并在整个策略的实施过程中，管理一个遵守下述循环不定时的边集合A。我们可以安全的将这种边加入到集合A中而不破坏A的循环不变式，称这样的边的集合为集合A的**安全边**。

**在每遍循环之前，A是某个最小生成树的一个子集。**

在每一步我们要做的事情就是选择选择一条边(u,v)，将其加入到集合A中，使A不违反循环不变式，即A并{(u,v)}也是某棵最小生成树的子集。

```c++
GenericMST()
    A = Ø
    while A does not form a spanning tree
        find an edge (u,v) is safe for A
        A = A ∪ {{u,v}}
    return A
```

**先给出一些定义**  
**切割**：无向图G=(V,E)的一个切割(S,V-S)，是集合V的一个划分。  
如果一条边一个端点在集合S中，一个端点在集合V-S中，则称改变**横跨**切割(S,V-S)。  
如果集合A中不存在横跨该切割的边，则称该切割**尊重**集合A。  
在横跨一个切割的所有边中，权重最小的边称为**轻量级边**，轻量级边可能不唯一。

**用来辨认安全边的规则由下面的定理给出**  
**定理23.1** 设G=(V,E)是一个在边E上定义了实数值权重函数W的连通无向图。设集合A为E的一个子集，且A包括在图G的某棵最小生成树中，设(S,V-S)是图G中尊重集合A的任意一个切割，又设(u,v)是横跨切割(S,V-S)的一条轻量级边，那么边(u,v)对于集合A是安全的。

**推论23.2** 设G=(V,E)是一个连通的无向图，并有定义在边集合E上实数权重函数w。设集合A为E的一个子集，且该子集包括在G的某棵最小生成树里，并设G=(V<sub>c</sub>,E<sub>c</sub>)为森林中G<sub>A</sub> = (V,A)中的一个连通分量（树）。如果边(u,v)是连接C和G<sub>A</sub>中某个其他连通分量的轻量级边，则边(u,v)对于集合A是安全的。