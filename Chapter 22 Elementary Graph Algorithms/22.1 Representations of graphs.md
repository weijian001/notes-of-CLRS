# 22.1 Representations of graphs

标签： 图

---
###笔记
图的搜索指的是系统化地跟随图中的边来访问图中的每个结点，图搜索可以发现图的结构。许多图算法在一开始都会先通过搜索来获取图的结构。

图G=(V,E)有两种表示方法，邻接矩阵和邻接链表。邻接链表因为在表示**稀疏图**(边数|E|远远小于|V|<sup>2</sup>)时非常紧凑成为通常的选择。不过，在**稠密图**(边数|E|接近|V|<sup>2</sup>)或需要快速判断任意两个结点之间是否有边相连时，更倾向于邻接矩阵（例如最短路径的两种算法）。邻接矩阵第i行表示结点i的出度，第i列表示结点i的入度。

邻接表表示由一个包含|V|条链表的数组Adj构成，每个结点有一条链表。Adj[u]包含图G中所有与u结点邻接的结点。若G是一个有向图，对于边(u,v)，结点v会出现在Adj[u]中，所有链表长度之和等于|E|。若G是无向图，所有链表长度之和等于|E|。但不管是有向还是无向，邻接链表表示法的存储空间需求均为θ(V+E)。

邻接矩阵和邻接链表也都可以表示**权重图**，邻接链表可以在数组的每个位置加上权值的位子，矩阵可以直接写。矩阵还有一个好处可以直接判断边(u,v)是否是图中的边，邻接矩阵则需要在Adj[u]中搜索是否存在v结点。

###练习
22.1-1：出度O(V)，入度O(V<sup>2</sup>)不过可以用一个数组记录下，可以优化为O(V)。  
22.1-2：本上。  
22.1-3从图G计算G的转置有效算法：邻接链表可以达到O(E)，但要用一些空间。邻接矩阵交换元素就可以（右上和坐下），时间是O(V<sup>2</sup>)。  
22.1-6给定邻接矩阵表示，给出一个O(V)的时间的算法来判断有向图G是否存在一个通用汇点：
```c++
IsSink(A,k)
    let A be |V|*|V|
    for j = 1 to |V|
        if a[k][j] = 1
            return false
    for i = 1 to |V|
        if a[i][k] = 0 and i != k
            return false
    return true
```
```c++
UniversialSink(A)
    let a be |V|*|V|
    i = j = 1
    while i <= |V| and j <= |V|
        if a[i][j] = 1
            i = i+1
        else
            j = j+1
    if i <= |V|
        return "There is no universial sink"
    else if IsSink(A,i) == FALSE
        return "There is no universial sink"
    else
        return "i is a universial sink"
```
**思路**：显而易见，如果第i行包括一个1，则i肯定不是通用汇点；如果第j列除了i==j的情况下有一个0，则j肯定不是通用汇点。这也是IsSink(A,k)的原理。对于UniversialSink，首先证明1<=k< i的结点不可能是通用汇点，因为由第5行知，第k行包含1。其次，我们证明i<k<=|V|不能是通用汇点，因为i<|V|，肯定是j出界了，那么我们在每一列都找到了一个0（因为只有找到了0，j才会加1，j越界证明我们已经找到了|V|个0），**因为我们没有到过i以下的行，所以这些k列的0都是非对角线上的**，因此i<k<=|V|的顶点也都不是通用汇点。所以通用汇点只可能是i，我们再用O(|V|)的算法检查i即可。  
因为我们值调用了一次O(|V|)的算法，所以整体算法是O(|V|)的。

