# 2.3设计算法

---

###笔记/例子

1. 分治法：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解然后来建立原问题的解。
2. 分治法在**每层递归**时都有三个步骤：
    * 分解，原问题为若干子问题，这些子问题是原问题规模较小的实例。 
    * 解决，递归地求解各子问题，若子问题的规模**最够小**，则直接求解。
    * 合并，这些子问题的解组成原问题的解。
3. Merge-Sort
```c++
//伪代码
MERGE(A,p,q,r)
    n1 = q-q+1
    n2 = p-(q+1)+1
    //复制到新的数组
    for i = 1 to n1
        L[i] = A[p+i-1]
    for j = 1 to n2
        R[i] = A[q+1+j-1]
    //添加哨兵
    L[n1+1] = ∞
    R[n2+1] = ∞
    //合并
    for k = p to r
        if L[i] < R[j]
            A[k] = L[i]
            i = i+1
        else
            A[k] = R[j]
            j = j+1
//归并排序
MERGE-SORT(A,p,r)
    if p < r
        q = (p+r)/2
        MERGE-SORT(A,p,q)
        MERGE-SORT(A,q+1,r)
        MERGE(A,p,q,r)
```

```c++
//c++实现
void myMerge(vector<int> &v, int p, int q, int r)
{
    //注意：是q-p
    int n1 = q-p+1, n2 = r-q;
    vector<int> ta, tb;
    //复制到新的vector中

    for (int i = 0; i < n1; i++)
        ta.push_back(v[p+i]);
    for (int j = 0; j < n2; j++)
        tb.push_back(v[q+1+j]);
    ta.push_back(INT_MAX);
    tb.push_back(INT_MAX);

    int i = 0, j = 0;
    for (int k = p; k <= r; k++)
    {
        if (ta[i] < tb[j])
        {
            v[k] = ta[i];
            i = i+1;
        }
        else
        {
            v[k] = tb[j];
            j = j+1;
        }
    }
}

void mergeSort(vector<int> &v, int p, int r)
{
    if (p < r)
    {
        int q = (p+r)/2;
        mergeSort(v, p, q);
        mergeSort(v, q+1, r);
        myMerge(v, p, q, r);
    }
}

int main()
{
    int temp[20] = {20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1};
    vector<int> v(temp, temp+20);
    print(v);
    mergeSort(v, 0, 19);
    print(v);
    return 0;
}
```
```java
	public static void main(String[] args) {
		int A[] = new int[]{4, 5, 6, 1, 10 ,9, 8, 2, 3, 7, 11, 19, 20, 18, 17, 16, 15, 14, 13, 12};
		MergeSort(A, 0, 19);
		print(A);
	}
	
	static void Merge(int[] A, int p, int q, int r) {
		int n1 = q-p+1, n2 = r-q;;
		int B[] = new int[20];
		int C[] = new int[20];
		int i = 0, j = 0;
		for (i = 0; i < n1; i++) {
			B[i] = A[p+i];
		}
		for (j = 0; j < n2; j++) {
			C[j] = A[q+1+j];
		}
		B[i]  = C[j] = Integer.MAX_VALUE;
		
		i = j = 0;
		int k = 0;
		for (k = p; k <= r; k++) {
			if (B[i] < C[j]) {
				A[k] = B[i];
				i = i+1;
			} else {
				A[k] = C[j];
				j = j+1;
			}
		}
	}
	
	static void MergeSort(int[]A,  int p, int r) {
		if (p < r) {
			int q = (p+r)/2;
			MergeSort(A, p, q);
			MergeSort(A, q+1, r);
			Merge(A, p, q, r);
		}
	}
```
> `int q = (p+r)/2;`可以产生规模为floor(n/2)和ceil(n/2)的两部分，即对于n为偶数，则产生个数相同的两部分；对于n为计数，则前一半比后一半多一个，和下标无关。

分治算法的分析：一般有以下递归式，
![2.3-1递归式][1]

归并排序的时间复杂度为O(nlgn)证明在P20-21，插入排序位O(n<sup>2</sup>)

  [1]: https://github.com/wj1066/pictures/blob/master/2.3-1.jpg