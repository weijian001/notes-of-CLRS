# 16.2 Elements of the greedy strategy

标签： 贪心算法 原理

---
###笔记
一般地，我们可以按照如下步骤设计贪心算法：  
1. 将最优化问题转化为这样的形式：对其作出一次选择后，只剩下一个子问题需要求解。  
2. 证明作出贪心选择后，原问题总是存在最优解。即贪心选择是安全的。  
3. 证明作出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可以得到原问题的最优解，这样就得到了最优子结构。

> 我们应该知道，每个贪心算法之下都有一个更繁琐的动态规划算法。

如何证明一个贪心算法能否解决一个最优化的问题？并没有适合所有情况的方法。但是**贪心选择性质**和**最优子结构**是两个性质两个关键因素。如果能证明这些性质，就向贪心算法迈出了重要一步。

**贪心选择性质(Greedy-choice property)**  
贪心选择性质：我们可以通过做出局部最优（贪心）选择来构造全局最优解。**即进行选择时，我们直接做出当前问题看起来最优的选择，而不必考虑子问题的解**。  
这也是和动规不同的，贪心算法在选择前可依赖之前做出的选择，但不依赖任何将来的选择和子问题的解。因此和动态规划先求解子问题才能进行第一次选择不同，贪心算法在第一次选择之前不求解任何子问题。一个动态规划算法是自底向上（带备忘的自顶向下也是先求解子问题）计算的，而一个贪心算法通常是自顶向下的，进行一次又一次的选择，将给定的问题的实例变下。  
当然，我们必须证明每一步做出贪心选择能生成全局最优解。如定理16.1，通常先考察某个子问题的最优解，然后用贪心选择替换某个选择来修改此解，从而得到一个相似但是更小的子问题。  
如果进行贪心选择时我们不得不考虑多种选择，通常以为着可以改进贪心选择，使其更为高效。例如上一个问题，如果我们先按照结束时间排好序，则对每个活动只需要处理一次。

**最优子结构**  
和动态规划的最优子结构性质相同。当应用贪心算法时，通常使用更为直接的最优子结构。我们可以假定通过对原问题应用贪心选择即可得子问题，我们真正要做的就是论证：将子问题的最优解和贪心选择组合在一起能生成原问题的最优解。

**贪心算法对动态规划算法**  
贪心算法和动规算法都用了最优子结构性质，有时候可能会用反。举一个相似但方法不同的例子。  
**0-1背包问题(0-1 knapsack problem)**：小偷发现了n个商品，第i个商品价值v<sub>i</sub>，重w<sub>i</sub>磅，v<sub>i</sub>和w<sub>i</sub>都是**整数**，背包最多容纳W磅的商品，W是一个整数。可以把商品理解为金锭。  
**分数背包问题(fractional knapsack problem)**：和上一个问题一样，不同的是小偷可以拿走一部分，可以把商品理解为金砂。

两个问题都具有最优子结构性质。对0-1问题，考虑重量不超过W而价值最高的方案，如果我们将商品j从此方案删除，则剩余商品必须是重量不超过W-w<sub>j</sub>的价值最高的方案。  
我们可以用贪心策略解决分数背包问题，时间复杂度为O(nlgn)（排序）。但是对0-1背包问题无效。当我们考虑是否将一个商品装入背包的时候，必须比较包含此商品的子问题的解和不包含此商品的子问题的解，然后做出选择，这会导致大量的重叠子问题---这是动态规划的标识。

###练习（订正，其他的是证明）
16.2-2：
```c++
Dynamic01Knapsack(w,v,n,W)
    let c[0..n,0..W] be a new table
    for i = 0 to W
        c[0,i] = 0
    for i = 1 to n
        c[i,0] = 0
    for i = 1 to n
        for w = 1 to W
            if wi <= w
                if vi + c[i-1,w-wi] > c[i-1, w]
                   c[i,w] =  vi + c[i-1,w-wi]
                else
                    c[i,w] = c[i-1][W]
            else
                c[i,w] = c[i-1][w]
```
```c++
//c++实现代码
//注意下输出最优方案的物品
#include <iostream>
#include <stdlib.h>
#include <stdio.h>
using namespace std;

void PrintItems(int *c, int i, int j, int n, int W, int w[])
{
    if (i == 0 || j == 0)
        return ;
    if ( *(c+i*(W+1)+j) == *(c+(i-1)*(W+1)+j) )
    {
        PrintItems(c, i-1, j, n, W, w);
    }
    else
    {
        PrintItems(c, i-1, j-w[i-1], n, W, w);
        cout << i << " ";
    }
}

int Dynamic01Knapsack(int w[], int v[], int n, int W)
{
    int c[n+1][W+1];
    for (int i = 0; i <= W; i++)
        c[0][i] = 0;
    for (int i = 1; i <= n; i++)
        c[i][0] = 0;
    for (int i = 1; i <= n; i++)
    {
        for (int weight = 1; weight <= W; weight++)
        {
            if (w[i-1] <= weight)   //两个w不能重复
            {
                if (v[i-1] + c[i-1][weight-w[i-1]] > c[i-1][weight])    //在w和v中，从0开始使用的
                    c[i][weight] = v[i-1] + c[i-1][weight-w[i-1]];
                else
                    c[i][weight] = c[i-1][weight];
            }
            else
                c[i][weight] = c[i-1][weight];
        }
    }
    cout << "选择了第几个物品：";
    PrintItems(&c[0][0], n, W, n, W, w);
    cout << endl;
    return c[n][W];
}

int main()
{
    freopen("out.txt", "w", stdout);
    int w[] = {2,2,6,5,4};
    int v[] = {6,3,5,4,6};
    int n = 5, W = 10;
    cout << "总价值" << Dynamic01Knapsack(w,v,n,W);
}
```

