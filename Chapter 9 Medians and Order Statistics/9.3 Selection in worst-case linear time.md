# 9.3 Selection in worst-case linear time

标签： 线性时间 选择算法

---

随机化选择算法，RandomizedSelect在最坏情况下运行时间为θ(n<sup>2</sup>)，因为是随机化算法，不存在特定的最坏情况的输入，但是不排除极不走运的情况。本节讨论一个最坏情况下运行时间为θ(n)的选择算法Select。

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <ctime>
using namespace std;

#define MAX (31)

//交换vector里的元素
void exchange(vector<int> &A, int a, int b)
{
    int t = A[a];
    A[a] = A[b];
    A[b] = t;
}

//获取vector中某一段的中位数（下中位数）
int getMedian(vector<int> &A, int l, int h)
{
    //插入排序
    for (int i = l+1; i <= h; i++)
    {
        int key = A[i];
        int j = i-1;
        while (j >= l && A[j] > key)
        {
            A[j+1] = A[j];
            j--;
        }
        A[j+1] = key;
    }
    //返回的是（下）中位数，不是下标
    return A[(l+h)/2];
}

//更改过的划分算法
//和其他不一样的是，pivot是其中的中位数，但是位置不确定
int partitionWithPivot(vector<int> &A, int p, int r, int pivot)
{
    int i = p-1;
    //j最大到r，而不是r-1，因为最后一个也不是主元
    for (int j = p; j <= r; j++)
    {
        //在快排或者随机化选择算法中，这里是<=，因为是维护四个区域，第一个是<=的主元的元素。
        //但是这里用<，是为了在下一个for循环把pivot放在正确的位置上
        if (A[i] < pivot)
        {
            i = i+1;
            exchange(A, i, j);
        }
    }

    //这个循环把pivot放到正确的位置进行划分
    for (int j = i+1; j <= r; j++)
    {
        if (A[i] == pivot)
        {
            exchange(A, i+1, j);
            break;
        }
    }
    return i+1;
}

//选择算法
//这里的i是第i个元素，不是下标
int Select(vector<int> &A, int p, int r, int i)
{
    if (p == r)
        return A[p];
    //共多少个元素，根据元素来判断中位数个数
    int len = r-p+1;
    //确定中位数个数
    int medianCnt = len%5 >0 ? len/5+1 : len/5;

    //存储每个组的中位数
    vector<int> median(medianCnt);
    for (int j = 0, k = p; j < medianCnt; j++)
    {
        if (j == medianCnt-1)
            median[j] = getMedian(A, k, r);
        else
            median[j] = getMedian(A, k, k+4);
        k = k+5;
    }

    //加1是重点，(medianCnt-1)/2得到中位数的下标，加1后才是第几个数
    //调试了很多次错误在这
    int pivot = Select(median, 0, medianCnt-1, (medianCnt-1)/2+1);

    int q = partitionWithPivot(A, p, r, pivot);
    int k = q-p+1;

    if (i == k)
        return A[q];
    else if (i < k)
        return Select(A, p, q-1, i);
    else
        return Select(A, q+1, r, i-k);

}

int main()
{
    srand((unsigned int)time(0));
    vector<int> v;
    for (int i = 0; i < MAX; i++)
        v.push_back(rand()%200);

    //方便查看结果
    sort(v.begin(), v.end());
    for (int i = 0; i < MAX; i++)
        cout << v[i] << " ";
    cout << endl;
    //

    cout<< Select(v, 0, v.size()-1, 5) << endl;

}
```






